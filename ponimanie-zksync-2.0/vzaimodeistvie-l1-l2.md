# Взаимодействие L1/L2

Хотя большинство операций исполняется на L2, некоторые из них требуют взаимодействия с сетью L1. Основными такими случаями являются построение сложных мостов, поддержание смарт-контрактов управления на одной сети, которые регулируют контракты на других сетях и т.д.

Кроме того, резистентность к цензуре на L2 наследуется от основной сети, поэтому возможность отправлять сообщения из Эфириума в zkSync является важной частью механизма резистентности к цензуре, называемого [приоритетной очередью](https://v2-docs.zksync.io/dev/zksync-v2/l1-l2-interop.html#priority-queue) (priority queue).

### L1 -> L2 коммуникация <a href="#l1-l2-communication" id="l1-l2-communication"></a>

Отправка транзакций с Эфириума на zkSync происходить через смарт-контракт zkSync. Это позволяет отправителю запрашивать транзакции напрямую из L1, тем самым обеспечивая беспрепятственную передачу любых данных с Эфириума в zkSync.

Sending transactions from Ethereum to zkSync is done via the zkSync smart contract. It allows the sender to request transactions directly from L1. Thereby allowing permissionless pass of any data from the Ethereum into zkSync.

### Приоритетная очередь <a href="#priority-queue" id="priority-queue"></a>

Задачей приоритетной очереди является предоставление резистентного к цензуре способа взаимодействия с zkSync в случае, если оператор становится злонамеренным или недоступным.

Способ работы приоритетный очереди на zkSync 2.0 очень близок к своему аналогу в предыдущей версии zkSync. Для полноты картины мы сначала презентуем способ работы приоритетной очереди на zkSync 1.x. Это даст нам понимание, почему для zkSync 2.0 необходим новый дизайн приоритетной очереди.

#### Как это работает zkSync 1.x <a href="#how-it-works-in-zksync-1-x" id="how-it-works-in-zksync-1-x"></a>

В предыдущей версии zkSync было всего две операции, которые могли быть отправлены на zkSync с L1:

* `Deposit`: перенос средств с Эфириума на zkSync.
* `FullExit`: Перенос средства назад на Эфириум. По сути, это то же самое, что и `Withdraw` в zkSync 2.0.

Если пользователь хотел отправить средства в, или вывести с zkSync, он должен был отправить запрос на транзакцию в смарт-контракт, который затем прикреплялся к двухсторонней очереди приоритетных транзакций. Двусторонняя очередь имеет следующие правила:

* Все транзакции обрабатываются поочередно.
* Каждая приоритетная операция должна быть обработана оператором в течение `X` дней с момента ее отправки в контракт.

Первое правило гарантированно обеспечивается смарт-контрактом. Второе правило может быть нарушено, если оператор становится злонамеренным или недоступным. В таком случае система входит в 'exodus mode' (режим исхода), в котором новые блоки не обрабатываются и пользователи могут извлечь свои средства без взаимодействия с оператором.

#### Какие изменения необходимы? <a href="#what-changes-are-needed" id="what-changes-are-needed"></a>

Описанный выше процесс отлично работает в системах с поддержкой небольшого набора относительно легких операций. zkSync 2.0 поддерживает универсальные вычисления для смарт-контрактов и, следовательно, некоторые принципы необходимо изменить для сохранения стабильности сети.

Во-первых, все транзакции должны поддерживаться приоритетной очередью. Пользователи могут иметь заблокированные средства в смарт-контракте L2, но не на своем собственном L2 аккаунте. Поэтому прежде чем переместить свои средства на L1, им нужно для начала отправить транзакцию `Execute` в zkSync для высвобождения средств из этого смарт-контракта.

Во-вторых, приоритетная очередь должна оставаться резистентной к цензуре. Но представьте, что случится, если пользователи начнут отправлять множество транзакций, которые заполняют весь лимит ergs в блоке? Должен быть способ предотвращения спам-атак на систему. Поэтому отправка транзакций в приоритетную очередь более не бесплатна. Пользователи должны платить определенную комиссию оператору для обработки их транзакций. Расчет точной комиссии децентрализованным способом является сложной задачей. Таким образом, комиссия за транзакцию равна `txBaseCost * gasPrice`. `gasPrice` - это цена газа за пользовательскую транзакцию, тогда как `txBaseCost` - это базовая цена транзакции, которая зависит от ее(транзакции) параметров (например, `ergs_limit` для транзакции `Execute` ).

В-третьих, оператор не может обещать проведение каждой транзакции в течение `Х` дней. И снова, это необходимо для предотвращения спам-атак на приоритетную очередь. Мы изменили это правило на следующее:

* Оператор должен выполнить как минимум `Х` количество работы (см. ниже) в приоритетной очереди, либо приоритетная очередь должна быть пуста.

Другими словами, мы требуем от оператора делать максимум вместо требования следовать строгим дедлайнам. Метод измерения количества "работы" еще предстоит разработать. Наиболее вероятно, что это будет количество `ergs`, использованных в приоритетных операциях.

В будущем мы также добавим возможность "приоритезации" транзакций типа L1->L2, позволяя пользователям регулировать скорость включения их транзакции в обмен на оплату более высокой комиссии оператору.

### Приоритетный режим (Priority mode) <a href="#priority-mode" id="priority-mode"></a>

Если оператору не удается провести необходимые транзакции на L1, система входит в "Приоритетный режим". В этом режиме любой может стать оператором путем стейкинга токенов. Более точные детали по приоритетному режиму пока находятся в разработке и будут описаны более детально ближе к запуску mainnet.&#x20;

Для снижения рисков альфа-mainnet запустится с механизмом немедленной остановки и модификации сети, что противоречит цели приоритетного режима. Приоритетный режим будет вводиться постепенно в последующих релизах.



### L2 -> L1 коммуникация <a href="#l2-l1-communication" id="l2-l1-communication"></a>

L2 -> L1 коммуникация, в отличие от L1 -> L2 коммуникации, основана только на передаче информации, а не на исполнении транзакций на L1. Это встроенная функция, выполненная из двух частей: отправки сообщения с L2 и чтения его на L1. Первая часть реализована как вызов системного смарт-контракта L2. Вторая часть же реализована на смарт-контракте zkSync на L1 в виде функции получателя (getter).

#### Отправка сообщений <a href="#sending-messages" id="sending-messages"></a>

Каждое сообщение, отправленное с L2 на L1 содержит в себе адрес отправителя и само сообщение. Длина сообщения может быть произвольной, но чем длиннее сообщение, тем дороже будет стоить его отправка. Оператор должен включать все сообщения для соответствующего дерева хэшей (см. следующий абзац). Таким образом, все сообщения доступны публично, и никому не нужно полагаться на оператора, чтобы раскрыть их.

#### Чтение сообщений <a href="#reading-messages" id="reading-messages"></a>

Каждое отправленное сообщение можно прочесть он-чейн. Более того, можно доказать, что сообщение было отправлено в конкретном блоке L2. Для того, чтобы сделать таке доказательство как можно более дешевым и для пользователя, и для оператора, мы храним все сообщения, для каждого блока L2, в дереве хэшей (merkle tree). Соответственно, любой смарт-контракт на L1 может принять отправленное сообщение путем предоставления доказательства включения в какой-либо из блоков L2. Доказательство может быть сгенерированно, основываясь лишь на данных, которые оператор отправил на смарт-контракт zkSync L1. Также доказательство может быть получено через [API](https://v2-docs.zksync.io/api/api.html#zksgetl2tol1msgproof).

#### Резюме по L2->L1 коммуникации <a href="#summary-on-l2-l1-messaging" id="summary-on-l2-l1-messaging"></a>

* Для L2 -> L1 комуникации нужна одна транзакция на L2 и одна транзакция на L1.&#x20;
* Сообщения могут быть произвольной длины.
* Вся необходимая информация для доказательства включения сообщения в блок L2 всегда может быть восстановлена из Эфириума. Однако, наиболее легким способом является запрос доказательства у оператора через API.
