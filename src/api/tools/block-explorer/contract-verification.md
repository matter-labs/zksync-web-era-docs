# Contract Verification

## What is contract verification?

When you deploy a smart contract on a network, you’re essentially deploying the bytecode produced by the Solidity compiler.

Verifying a contract entails determining whether the on-chain bytecode matches a given source code when it is compiled. If it does, we can state that we have confirmed the bytecode's source code's integrity. Hence the name – verification.


## How are smart contracts verified in zkSync?

The deployed bytecode and the Solidity source code of a smart contract are compared during the verification process using zkSync. The algorithm compiles the source code to compare the generated bytecode to the deployed one.
<br>
If the two sides match in every way, the contract is verified.

Code verification requires six arguments: 

- The contract address
- The contract name
- The source code, including the source of all imports
- The version of the compiler used to produce the deployed bytecode
- Information about the number of compiler optimizations (if any)
- The constructor arguments
 
 If any of these pieces of information is wrong, the process of verification fails.


## Source code privacy

When your smart contract is deployed on zkSync and verified on the block explorer, users can check the verified source code and interact with it.

## Verifying Contracts Using the zkSync Block Explorer

To get started click the **Tools** tab in the top header, a dropdown will pop up and select **Smart Contract Verification**,  after which you will be shown the following screen:

![Smart Contract Verification page!](../../../assets/images/verify-contract.png "verify contract")

### Enter contract details

To verify the contract, enter the following details;

- Contract address: The address provided must match with the `0x` address generated during contract creation.
- Contract name: The name must be identical to the name provided in the contract.
- Optimization: This checks whether or not optimization was used while compiling the contract. If you enabled optimization during compilation, check **Yes** otherwise select **No**
- Solidity compiler version(Solc): This specifies the exact version of the compiler used to compile a smart contract. Click on the dropdown to specify the compiler version used. We encourage you to use version `0.8.16`.
- zkSync compiler version(Zksolc): The zkSync compiler version used, the default is set to `v1.2.0`.
  
<br>

![Compiler version!](../../../assets/images/compiler-version.png "compiler version")

- Enter the Solidity Contract code: Copy the code from your editor and paste it into the text area.
<br>
**Note:** You may need to flatten your Solidity code if it utilizes a library or inherits dependencies from another contract. 
<br> 
We recommend using [Hardhat flatten](https://medium.com/coinmonks/flattening-smart-contracts-using-hardhat-dffe7dbc7b3f), [Truffle flattener](https://github.com/NomicFoundation/truffle-flattener) or the [POA Solidity flattener](https://github.com/poanetwork/solidity-flattener).


- Constructor arguments: If constructor arguments are required by the contract, you should add them here, but in [ABI hex-encoded form](https://solidity.readthedocs.io/en/develop/abi-spec.html).
  
<br>

### How can you obtain your constructor arguments?

> **Note:** The easiest way to get the constructor argument data is to print it to the console while deploying.

For example, if using our [tutorial](../../../dev/developer-guides/hello-world.md), you can find the line:

```js
const greeterContract = await deployer.deploy(artifact, [greeting]);
```

if you add the next line as

```js
console.log(greeterContract.interface.encodeDeploy([greeting]));
```

then you will receive constructor argument data.

- Lastly, click the **Verify Smart Contract** button.
  
<br>
If all goes well, you will see a success message.

<br>

![Smart Contract Verified!](../../../assets/images/contract-verified.png "Contract Verified")
