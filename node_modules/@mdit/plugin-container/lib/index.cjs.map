{"version":3,"file":"index.cjs","sources":["../src/plugin.ts"],"sourcesContent":["/**\n * Forked and modified from https://github.com/markdown-it/markdown-it-container/blob/master/index.js\n */\n\nimport type { Options, PluginWithOptions } from \"markdown-it\";\nimport type Token from \"markdown-it/lib/token.js\";\nimport type Renderer from \"markdown-it/lib/renderer.js\";\nimport type { RuleBlock } from \"markdown-it/lib/parser_block.js\";\nimport type { MarkdownItContainerOptions } from \"./options.js\";\n\nexport const container: PluginWithOptions<MarkdownItContainerOptions> = (\n  md,\n  {\n    name,\n    marker = \":\",\n    validate = (params: string): boolean =>\n      params.trim().split(\" \", 2)[0] === name,\n    openRender = (\n      tokens: Token[],\n      index: number,\n      options: Options,\n      _env: unknown,\n      slf: Renderer\n    ): string => {\n      // add a class to the opening tag\n      tokens[index].attrJoin(\"class\", name);\n\n      return slf.renderToken(tokens, index, options);\n    },\n    closeRender = (\n      tokens: Token[],\n      index: number,\n      options: Options,\n      _env: unknown,\n      slf: Renderer\n    ): string => slf.renderToken(tokens, index, options),\n  } = { name: \"\" }\n) => {\n  const MIN_MARKER_NUM = 3;\n  const markerStart = marker[0];\n  const markerLength = marker.length;\n\n  const container: RuleBlock = (state, startLine, endLine, silent) => {\n    let start = state.bMarks[startLine] + state.tShift[startLine];\n    let max = state.eMarks[startLine];\n\n    // Check out the first character quickly,\n    // this should filter out most of non-containers\n    //\n    if (markerStart !== state.src[start]) return false;\n\n    let pos = start + 1;\n\n    // Check out the rest of the marker string\n    while (pos <= max) {\n      if (marker[(pos - start) % markerLength] !== state.src[pos]) break;\n      pos += 1;\n    }\n\n    const markerCount = Math.floor((pos - start) / markerLength);\n\n    if (markerCount < MIN_MARKER_NUM) return false;\n\n    pos -= (pos - start) % markerLength;\n\n    const markup = state.src.slice(start, pos);\n    const params = state.src.slice(pos, max);\n\n    if (!validate(params, markup)) return false;\n\n    // Since start is found, we can report success here in validation mode\n\n    if (silent) return true;\n\n    let nextLine = startLine;\n    let autoClosed = false;\n\n    // Search for the end of the block\n    while (\n      // unclosed block should be auto closed by end of document.\n      // also block seems to be auto closed by end of parent\n      nextLine < endLine\n    ) {\n      nextLine += 1;\n      start = state.bMarks[nextLine] + state.tShift[nextLine];\n      max = state.eMarks[nextLine];\n\n      if (start < max && state.sCount[nextLine] < state.blkIndent)\n        // non-empty line with negative indent should stop the list:\n        // - ```\n        //  test\n        break;\n\n      if (\n        // match start\n        markerStart === state.src[start] &&\n        // closing fence should be indented less than 4 spaces\n        state.sCount[nextLine] - state.blkIndent < 4\n      ) {\n        // check rest of marker\n        for (pos = start + 1; pos <= max; pos++)\n          if (marker[(pos - start) % markerLength] !== state.src[pos]) break;\n\n        // closing code fence must be at least as long as the opening one\n        if (Math.floor((pos - start) / markerLength) >= markerCount) {\n          // make sure tail has spaces only\n          pos -= (pos - start) % markerLength;\n          pos = state.skipSpaces(pos);\n\n          if (pos >= max) {\n            // found!\n            autoClosed = true;\n            break;\n          }\n        }\n      }\n    }\n\n    const oldParent = state.parentType;\n    const oldLineMax = state.lineMax;\n\n    // @ts-expect-error\n    state.parentType = \"container\";\n\n    // this will prevent lazy continuations from ever going past our end marker\n    state.lineMax = nextLine;\n\n    const openToken = state.push(`container_${name}_open`, \"div\", 1);\n\n    openToken.markup = markup;\n    openToken.block = true;\n    openToken.info = params;\n    openToken.map = [startLine, nextLine];\n\n    state.md.block.tokenize(state, startLine + 1, nextLine);\n\n    const closeToken = state.push(`container_${name}_close`, \"div\", -1);\n\n    closeToken.markup = state.src.slice(start, pos);\n    closeToken.block = true;\n\n    state.parentType = oldParent;\n    state.lineMax = oldLineMax;\n    state.line = nextLine + (autoClosed ? 1 : 0);\n\n    return true;\n  };\n\n  md.block.ruler.before(\"fence\", `container_${name}`, container, {\n    alt: [\"paragraph\", \"reference\", \"blockquote\", \"list\"],\n  });\n  md.renderer.rules[`container_${name}_open`] = openRender;\n  md.renderer.rules[`container_${name}_close`] = closeRender;\n};\n"],"names":["container","md","name","marker","validate","params","openRender","tokens","index","options","_env","slf","closeRender","markerStart","markerLength","state","startLine","endLine","silent","start","max","pos","markerCount","markup","nextLine","autoClosed","oldParent","oldLineMax","openToken","closeToken"],"mappings":"aAUO,MAAMA,EAA2D,CACtEC,EACA,CACE,KAAAC,EACA,OAAAC,EAAS,IACT,SAAAC,EAAYC,GACVA,EAAO,KAAO,EAAA,MAAM,IAAK,CAAC,EAAE,KAAOH,EACrC,WAAAI,EAAa,CACXC,EACAC,EACAC,EACAC,EACAC,KAGAJ,EAAOC,GAAO,SAAS,QAASN,CAAI,EAE7BS,EAAI,YAAYJ,EAAQC,EAAOC,CAAO,GAE/C,YAAAG,EAAc,CACZL,EACAC,EACAC,EACAC,EACAC,IACWA,EAAI,YAAYJ,EAAQC,EAAOC,CAAO,CACrD,EAAI,CAAE,KAAM,EAAG,IACZ,CAEH,MAAMI,EAAcV,EAAO,GACrBW,EAAeX,EAAO,OAEtBH,EAAuB,CAACe,EAAOC,EAAWC,EAASC,IAAW,CAClE,IAAIC,EAAQJ,EAAM,OAAOC,GAAaD,EAAM,OAAOC,GAC/CI,EAAML,EAAM,OAAOC,GAKvB,GAAIH,IAAgBE,EAAM,IAAII,GAAQ,MAAO,GAE7C,IAAIE,EAAMF,EAAQ,EAGlB,KAAOE,GAAOD,GACRjB,GAAQkB,EAAMF,GAASL,KAAkBC,EAAM,IAAIM,IACvDA,GAAO,EAGT,MAAMC,EAAc,KAAK,OAAOD,EAAMF,GAASL,CAAY,EAE3D,GAAIQ,EAAc,EAAgB,MAAO,GAEzCD,IAAQA,EAAMF,GAASL,EAEvB,MAAMS,EAASR,EAAM,IAAI,MAAMI,EAAOE,CAAG,EACnChB,EAASU,EAAM,IAAI,MAAMM,EAAKD,CAAG,EAEvC,GAAI,CAAChB,EAASC,EAAQkB,CAAM,EAAG,MAAO,GAItC,GAAIL,EAAQ,MAAO,GAEnB,IAAIM,EAAWR,EACXS,EAAa,GAGjB,KAGED,EAAWP,IAEXO,GAAY,EACZL,EAAQJ,EAAM,OAAOS,GAAYT,EAAM,OAAOS,GAC9CJ,EAAML,EAAM,OAAOS,GAEf,EAAAL,EAAQC,GAAOL,EAAM,OAAOS,GAAYT,EAAM,aAMlD,GAEEF,IAAgBE,EAAM,IAAII,IAE1BJ,EAAM,OAAOS,GAAYT,EAAM,UAAY,EAC3C,CAEA,IAAKM,EAAMF,EAAQ,EAAGE,GAAOD,GACvBjB,GAAQkB,EAAMF,GAASL,KAAkBC,EAAM,IAAIM,GADvBA,IAChC,CAGF,GAAI,KAAK,OAAOA,EAAMF,GAASL,CAAY,GAAKQ,IAE9CD,IAAQA,EAAMF,GAASL,EACvBO,EAAMN,EAAM,WAAWM,CAAG,EAEtBA,GAAOD,GAAK,CAEdK,EAAa,GACb,KACF,CAEJ,CAGF,MAAMC,EAAYX,EAAM,WAClBY,EAAaZ,EAAM,QAGzBA,EAAM,WAAa,YAGnBA,EAAM,QAAUS,EAEhB,MAAMI,EAAYb,EAAM,KAAK,aAAab,SAAa,MAAO,CAAC,EAE/D0B,EAAU,OAASL,EACnBK,EAAU,MAAQ,GAClBA,EAAU,KAAOvB,EACjBuB,EAAU,IAAM,CAACZ,EAAWQ,CAAQ,EAEpCT,EAAM,GAAG,MAAM,SAASA,EAAOC,EAAY,EAAGQ,CAAQ,EAEtD,MAAMK,EAAad,EAAM,KAAK,aAAab,UAAc,MAAO,EAAE,EAElE,OAAA2B,EAAW,OAASd,EAAM,IAAI,MAAMI,EAAOE,CAAG,EAC9CQ,EAAW,MAAQ,GAEnBd,EAAM,WAAaW,EACnBX,EAAM,QAAUY,EAChBZ,EAAM,KAAOS,GAAYC,EAAa,EAAI,GAEnC,EACT,EAEAxB,EAAG,MAAM,MAAM,OAAO,QAAS,aAAaC,IAAQF,EAAW,CAC7D,IAAK,CAAC,YAAa,YAAa,aAAc,MAAM,CACtD,CAAC,EACDC,EAAG,SAAS,MAAM,aAAaC,UAAeI,EAC9CL,EAAG,SAAS,MAAM,aAAaC,WAAgBU,CACjD"}