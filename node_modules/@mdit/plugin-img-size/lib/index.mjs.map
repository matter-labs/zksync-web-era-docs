{"version":3,"file":"index.mjs","sources":["../src/plugin.ts"],"sourcesContent":["/**\n * Fork and edited from https://github.com/tatsy/markdown-it-imsize/blob/master/lib/index.js\n */\n\nimport type { PluginSimple } from \"markdown-it\";\nimport type { RuleInline } from \"markdown-it/lib/parser_inline.js\";\nimport type Token from \"markdown-it/lib/token.js\";\nimport type { ImgSizeEnv } from \"./types.js\";\n\n// Parse image size\n//\nconst parseNumber = (\n  str: string,\n  pos: number,\n  max: number\n): { ok: boolean; pos: number; value: string } => {\n  let char: string;\n  const start = pos;\n  const result = {\n    ok: false,\n    pos: pos,\n    value: \"\",\n  };\n\n  char = str.charAt(pos);\n\n  while ((pos < max && char.match(/\\d/)) || char === \"%\") {\n    char = str.charAt(++pos);\n  }\n\n  result.ok = true;\n  result.pos = pos;\n  result.value = str.slice(start, pos);\n\n  return result;\n};\n\nconst parseImageSize = (\n  str: string,\n  pos: number,\n  max: number\n): { ok: boolean; pos: number; width: string; height: string } => {\n  const result = {\n    ok: false,\n    pos: 0,\n    width: \"\",\n    height: \"\",\n  };\n\n  if (pos >= max) return result;\n\n  if (str.charAt(pos) !== \"=\") return result;\n\n  pos += 1;\n\n  // size must follow = without any white spaces as follows\n  // (1) =300x200\n  // (2) =300x\n  // (3) =x200\n  const char = str.charAt(pos);\n\n  if (char !== \"x\" && !char.match(/\\d/)) return result;\n\n  // parse width\n  const width = parseNumber(str, pos, max);\n\n  pos = width.pos;\n\n  // next character must be 'x'\n  if (str.charAt(pos) !== \"x\") return result;\n\n  pos += 1;\n\n  // parse height\n  const height = parseNumber(str, pos, max);\n\n  pos = height.pos;\n\n  result.width = width.value;\n  result.height = height.value;\n  result.pos = pos;\n  result.ok = true;\n\n  return result;\n};\n\nconst imgSizeRule: RuleInline = (state, silent) => {\n  const env = <ImgSizeEnv>state.env;\n  const oldPos = state.pos;\n  const max = state.posMax;\n\n  if (state.src.charAt(state.pos) !== \"!\") return false;\n  if (state.src.charAt(state.pos + 1) !== \"[\") return false;\n\n  const labelStart = state.pos + 2;\n  const labelEnd = state.md.helpers.parseLinkLabel(state, state.pos + 1, false);\n\n  // parser failed to find ']', so it's not a valid link\n  if (labelEnd < 0) return false;\n\n  let pos = labelEnd + 1;\n  let char: string;\n\n  let href = \"\";\n  let title = \"\";\n  let width = \"\";\n  let height = \"\";\n\n  if (pos < max && state.src.charAt(pos) === \"(\") {\n    //\n    // Inline link\n    //\n\n    // [link](  <href>  \"title\"  )\n    //        ^^ skipping these spaces\n    pos += 1;\n\n    for (; pos < max; pos++) {\n      char = state.src.charAt(pos);\n      if (char !== \" \" && char !== \"\\t\") break;\n    }\n\n    if (pos >= max) return false;\n\n    // [link](  <href>  \"title\"  )\n    //          ^^^^^^ parsing link destination\n    let res;\n\n    res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);\n\n    if (res.ok) {\n      href = state.md.normalizeLink(res.str);\n\n      if (state.md.validateLink(href)) pos = res.pos;\n      else href = \"\";\n    }\n\n    // [link](  <href>  \"title\"  )\n    //                ^^ skipping these spaces\n    const start = pos;\n\n    for (; pos < max; pos++) {\n      char = state.src.charAt(pos);\n      if (char !== \" \" && char !== \"\\t\") break;\n    }\n\n    // [link](  <href>  \"title\"  )\n    //                  ^^^^^^^ parsing link title\n    res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);\n\n    if (pos < max && start !== pos && res.ok) {\n      title = res.str;\n      pos = res.pos;\n\n      // [link](  <href>  \"title\"  )\n      //                         ^^ skipping these spaces\n      for (; pos < max; pos++) {\n        char = state.src.charAt(pos);\n        if (char !== \" \" && char !== \"\\t\") break;\n      }\n    } else title = \"\";\n\n    // [link](  <href>  \"title\" =WxH  )\n    //                          ^^^^ parsing image size\n    if (pos - 1 >= 0) {\n      char = state.src.charAt(pos - 1);\n\n      // there must be at least one white spaces\n      // between previous field and the size\n      if (char === \" \") {\n        res = parseImageSize(state.src, pos, state.posMax);\n        if (res.ok) {\n          width = res.width;\n          height = res.height;\n          pos = res.pos;\n\n          // [link](  <href>  \"title\" =WxH  )\n          //                              ^^ skipping these spaces\n          for (; pos < max; pos++) {\n            char = state.src.charAt(pos);\n            if (char !== \" \" && char !== \"\\n\") break;\n          }\n        }\n      }\n    }\n\n    if (pos >= max || state.src.charAt(pos) !== \")\") {\n      state.pos = oldPos;\n\n      return false;\n    }\n    pos += 1;\n  } else {\n    let label = \"\";\n\n    //\n    // Link reference\n    //\n    if (typeof env.references === \"undefined\") return false;\n\n    if (pos < max && state.src.charAt(pos) === \"[\") {\n      const start = pos + 1;\n\n      pos = state.md.helpers.parseLinkLabel(state, pos);\n\n      if (pos >= 0) label = state.src.slice(start, pos++);\n      else pos = labelEnd + 1;\n    } else pos = labelEnd + 1;\n\n    // covers label === '' and label === undefined\n    // (collapsed reference link and shortcut reference link respectively)\n    if (!label) label = state.src.slice(labelStart, labelEnd);\n\n    const ref = env.references[state.md.utils.normalizeReference(label)];\n\n    if (!ref) {\n      state.pos = oldPos;\n\n      return false;\n    }\n\n    href = ref.href;\n    title = ref.title || \"\";\n  }\n\n  //\n  // We found the end of the link, and know for a fact it's a valid link;\n  // so all that's left to do is to call tokenizer.\n  //\n  if (!silent) {\n    const content = state.src.slice(labelStart, labelEnd);\n    const tokens: Token[] = [];\n\n    state.md.inline.parse(content, state.md, state.env, tokens);\n\n    const token = state.push(\"image\", \"img\", 0);\n\n    token.attrs = <[string, string][]>[\n      [\"src\", href],\n      [\"alt\", \"\"],\n    ];\n    if (title) token.attrs.push([\"title\", title]);\n    if (width !== \"\") token.attrs.push([\"width\", width]);\n    if (height !== \"\") token.attrs.push([\"height\", height]);\n\n    token.children = tokens;\n    token.content = content;\n  }\n\n  state.pos = pos;\n  state.posMax = max;\n\n  return true;\n};\n\nexport const imgSize: PluginSimple = (md) => {\n  md.inline.ruler.before(\"emphasis\", \"image\", imgSizeRule);\n};\n"],"names":["parseNumber","str","pos","max","char","start","result","parseImageSize","width","height","imgSizeRule","state","silent","env","oldPos","labelStart","labelEnd","href","title","res","label","ref","content","tokens","token","imgSize","md"],"mappings":"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"}