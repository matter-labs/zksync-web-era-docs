# Поддержка абстракции аккаунта (АА)

### Введение <a href="#introduction" id="introduction"></a>

В Эфириуме существует два типа аккаунтов: [аккаунты, находящиеся во внешнем владении (ЕОА)](https://ethereum.org/en/developers/docs/accounts/#externally-owned-accounts-and-key-pairs), и [счета смарт-контрактов](https://ethereum.org/en/developers/docs/accounts/#contract-accounts). Только первый тип может инициировать транзакции, в то время как только второй может реализовывать произвольную логику. Для некоторых случаев использования, таких как кошельки в виде смарт-контрактов или протоколы конфиденциальности, эта разница может создавать много трений. В результате они требуют ретрансляторов L1, то есть EOA, чтобы облегчить транзакции из смарт-контракт-кошелька.

Аккаунты в zkSync 2.0 могут инициировать транзакции, как EOA, но и также могут иметь имплементированную произвольную логику, как смарт-контракт. Эта функция называется "абстракция аккаунта" и направлена она на решение проблем, описанных выше.

{% hint style="warning" %}
**Нестабильная функция**

Это тестовая реализация абстракции аккаунта (AA) на zkSync 2.0. Мы будем рады получить от вас обратную связь! Пожалуйста, учтите: следует ожидать значительных изменений в API/интерфейсах, необходиых для АА.

zkSync 2.0 одна из первых EVM-совместимых сетей, адаптирующих АА, так что данный тестнет используется в том числе и для наблюдения за тем, как "классические" проекты из EVM-сетей сосуществуют с функцией абстракции аккаунта.
{% endhint %}

#### Подготовка <a href="#prerequisites" id="prerequisites"></a>

Для лучшего понимания данного раздела мы рекомендуем ознакомиться с руководством по [аккаунтам](https://ethereum.org/en/developers/docs/accounts/) в Эфириум.

### Дизайн <a href="#design" id="design"></a>

Протокол абстракции аккаунта на zkSync по духу очень близок к [EIP4337](https://eips.ethereum.org/EIPS/eip-4337), хотя наш протокол по-прежнему реализован иначев угоду эффективности и лучшему пользовательскому опыту.&#x20;

#### Сохранение nonces уникальными <a href="#keeping-nonces-unique" id="keeping-nonces-unique"></a>

{% hint style="warning" %}
**Ожидайте изменений**

Текущая модель имеет несколько важных минусов: она не позволяет кастомным кошелькам отправлять множество транзакций одновременно, сохраняя при этом определенный порядок. Для ЕОА-аккаунтов nonce'ы должны увеличиваться последовательно, тогда как для кастомных аккаунтов порядок транзакций не может быть определен на 100%.

В будущем мы планируем перейти на модель, где аккаунты смогут выбирать, хотят ли они иметь последовательное упорядочивание для nonce (как у ЕОА), или все же хотят иметь произвольное упорядочивание.
{% endhint %}

Одним из важнейших инвариантов любого блокчейна является то, что каждая транзакция имеет уникальный хэш. Сохранение этой черты с произвольной абстракцией аккаунта - нетривиальная задача, хотя аккаунты, в общем-то, могут принимать множество идентичных транзакций. Хоть эти транзакции и были бы технически валидными по правилам блокчейна, нарушение уникальности хэша было бы сложным элементом для обработки для индексеров и прочих инструментов.

Необходимо решение на уровне протокола, которое было бы и дешевым для пользователей, и эффективным в случае злонамеренности оператора(безопасным). Один из наиболее простых способов удостовериться, что хэши транзакций не повторяются - это всегда иметь уникальную пару (sender, nonce).

Используется следующий протокол:

* Перед началом транзакции система делает запрос к [NonceHolder](https://v2-docs.zksync.io/dev/developer-guides/contracts/system-contracts.html#inonceholder) для проверки был ли предоставленный nonce уже использован.
* Если nonce еще не использовался, запускается валидация транзакции. Предоставленный nonce помечается как "использованный" на этом этапе.
* После валидации система проверяет, помечен ли этот nonce как использованный.

Пользователям будет позволено использовать любое 256-битное число в качестве nonce, и они могу вставить любое ненулевое значение под соответствующий ключ в системном контракте. Это уже поддерживается протоколом, но не на уровне сервера.

Больше документации по различным типам взаимодействия с системным контрактом `NonceHolder` наряду с руководствами будет доступно, как только мы добавим поддержку на уровне сервера. Сейчас рекомендуется использовать только метод `incrementNonceIfEquals`, который буквально обеспечивает соблюдение последовательного упорядочивания nonce'ов.

#### Стандартизация хэшей транзакций

В будущем планируется поддержка эффективных доказательств о включении транзакций в zkSync. Для этого нам потребуется высчитывать хэш транзакции в \[bootloader]\(.. /contracts/system-contracts.md#bootloader). Так как эти вычисления будут небесплатными для пользователя, единственным честным решением будет включение хэша транзакции в интерфейс методов АА (в случае, если аккаунту понадобится это значение по какой-либо причине). Поэтому все методы интерфейсов `IAccount` и `IPaymaster` (которые описаны ниже) включают в себя хэш транзакции наряду с рекомендуемым подписанным дайджестом (дайджест, подписанный ЕОА для данной транзакции).

#### IAccount интерфейс <a href="#iaccount-interface" id="iaccount-interface"></a>

* `validateTransaction` - обязательный метод, используется системой для определения соглашается ли логика АА провести транзакцию. В случае непринятия транзакции (например, подпись неверная) метод должен сделать отмену. В случае успешного вызова этого метода, реализованная логика аккаунта должна принять транзакцию и система продолжит ее исполнение.
* `executeTransaction` - обязательный метод, вызывается системой после снятия комиссии с пользователя. Эта функция выполняет исполнение транзакции.
* `payForTransaction` - опциональный метод, вызывается системой если у транзакции нет paymaster'a, т.е. аккаунт хочет заплатить за транзакцию. Этот метод следует использовать для оплаты аккаунтом комиссий. Примите во внимание, что если ваш аккаунт никогда не будет платить комиссий и всегда будет полагаться на функцию [paymaster](podderzhka-abstrakcii-akkaunta-aa.md#paymasters), то вам не нужно внедрять этот метод. Этот метод должен отправлять как минимум `tx.gasprice * tx.ergsLimit` ETH в пользу [bootloader](broken-reference) адреса.
* `prePaymaster` - опциональный метод, вызывается системой если у транзакции есть paymaster, т.е. есть другой адрес, который оплачивает транзакционные комиссии за пользователя. Этот метод следует использовать для подготовки ко взаимодействию с paymaster. Один из замечательных [примеров](podderzhka-abstrakcii-akkaunta-aa.md#approval-based-poryadok-ispolneniya-paymaster.), где это может быть полезно - это одобрение траты ERC-20 Токенов для paymaster'a.
* `executeTransactionFromOutside` - технически, не обязательный, но _строго рекомендуемый метод_, так как должен быть какой-то способ, в случае приоритетного режима (например, оператор не отвечает), запускать транзакции "извне" (по сути, это откат к стандартному Эфириумовскому подходу, где ЕОА инициирует транзакцию из смарт-контракта).&#x20;

#### IPaymaster интерфейс <a href="#ipaymaster-interface" id="ipaymaster-interface"></a>

Как и в оригинальном EIP4337, наш протокол абстракции аккаунта поддерживает paymasters: аккаунты, которые могут возмещать стоимость транзакций других аккаунтов. Вы можете больше узнать о них [здесь](https://v2-docs.zksync.io/dev/developer-guides/aa.html#paymasters).&#x20;

Каждый paymaster должен применять интерфейс [IPaymaster](https://github.com/matter-labs/v2-testnet-contracts/blob/main/l2/system-contracts/interfaces/IPaymaster.sol). Он включает себя 2 следующих метода:

* `validateAndPayForPaymasterTransaction` - обязательный метод, используется системой для определения одобряет ли paymaster оплату данной транзакции. Если paymaster будет оплачивать транзакцию, то этот метод должен отправить как минимум `tx.gasprice * tx.ergsLimit` ETH в пользу оператора. Он должен вернуть `context,` который будет являться одним из параметров вызова метода `postOp.` &#x20;
* `postOp` - опциональный метод и вызывается после исполнения транзакции. Заметьте, несмотря на оригинаться EIP4337, _нет гарантий, что этот метод будет вызван_. В частности, данный метод не будет вызван, если транзакция провалится с ошибкой `out of gas`. Он (метод) принимает в себя 4 параметра: `context` возвращенный методом `validateAndPayForPaymasterTransaction`; саму транзакцию; было ли исполнение транзакции успешным; и максимальной количество `ergs`, которое можно компенсировать paymaster'у. Более подробная документация по компенсациям будет доступна, как только их поддержка будет добавлена в zkSync.

#### `Reserved` поля специального назначения в структуре `Transaction`  <a href="#reserved-fields-of-the-transaction-struct-with-special-meaning" id="reserved-fields-of-the-transaction-struct-with-special-meaning"></a>

Примите во внимание, что каждый из вышеописанных методов принимает стуктуру [Transaction](https://github.com/matter-labs/v2-testnet-contracts/blob/0e1c95969a2f92974370326e4430f03e417b25e7/l2/system-contracts/TransactionHelper.sol#L15). В то время как некоторые из его полей говорят сами за себя, существует еще 6 `reserved` полей, значение каждого из которых отпределяются типом транзакции. Мы решили не давать этим полям названий, так как они могут быть лишними для некоторых будущих типов транзакций. На данный момент:

* `reserved[0]` - поле для nonce.
* `reserved[1]` - поле для `msg.value` , которое должно быть передано с транзакцией.

### Порядок исполнения транзакции <a href="#the-transaction-flow" id="the-transaction-flow"></a>

Каждая тразакция исполняется по определенному порядку:

**Этап валидации**

На этапе валидации аккаунт должен решить, принимает ли он транзакцию, и если да, то оплатить комиссию за нее. Если любой из элементов валидации проваливается, комиссия с аккаунта не взимается и данная транзакция не может быть включена в блок.

**Шаг 1.** Система проверяет, не был ли nonce транзакции использован ранее. Вы можете прочитать больше о сохранение nonce уникальным [здесь](https://v2-docs.zksync.io/dev/developer-guides/aa.html#keeping-nonces-unique).

**Шаг 2.** Система вызывает метод аккаунта `validateTransaction`. Если он не отменяется, переходим к следующему шагу.

**Шаг 3.** Система проверяет, был ли nonce транзакции помечен как "использованный".

**Шаг 4 (без paymaster).** Система вызывает метод аккаунта `payForTransaction`. Если он не отменяется, переходим к третьему шагу.

**Шаг 4 (с paymaster).** Система вызывает метод отправителя `prePaymaster` . Если он не отменяется, далее вызывается метод paymaster'a `validateAndPayForPaymasterTransaction.` Если он тоже не отменяется, то переходим к третьему шагу.

**Шаг 5.** Система проверяет, получил ли bootloader как минимум `tx.ergsPrice * tx.ergsLimit` ETH. Если результат положительный, то верификация считается пройденной и мы можем перейти к следующему этапу.&#x20;

\
**Этап исполнения**.

Этап исполнения отвечает за само исполнение транзакции и возврат неиспользованного ergs назад пользователю. Если на этом этапе есть какие-либо отмены, то транзакция все равно считаете валидной и будет включена в блок.

**Шаг 6.** Система вызвает метод аккаунта `executeTransaction.`

**Шаг 7. (только в случае если у транзакции есть paymaster)** Вызывается метод paymaster'a `postOp`. Этот шаг следует использовать для компенсации неиспользованного ergs отправителю в случае если paymaster использовался для оплаты транзакций в токенах ERC-20.

### Комиссии <a href="#fees" id="fees"></a>

В EIP4337 вы можете найти 3 типа газовых лимитов: `verificationGas`, `executionGas`, `preVerificationGas`, которые описывают газовые лимиты для разных этапов включения транзакции в блок. В zkSync только одно поле `ergsLimit`, которое покрывает комиссию для всех трех. При отправке транзакции убедитесь, что значение `ergsLimit` достаточно для покрытия издержек за верификацию, оплату комиссии (упомянутый выше ERC20 трансфер), и само исполнение.&#x20;

По умолчанию, вызов `estimateGas` добавляет константу, включающую расчет комиссии и верификацию подписи для ЕОА-аккаутов.

### Использование библиотеки `SystemContractsCaller` <a href="#using-the-systemcontractscaller-library" id="using-the-systemcontractscaller-library"></a>

В целях безопасности оба системных контракта `NonceHolder` и `ContractDeployer` могут быть вызваны только со специальном флагом `isSystem`. Вы можете узнать больше об этом [здесь](https://v2-docs.zksync.io/dev/developer-guides/contracts/system-contracts.html#protected-access-to-some-of-the-system-contracts). Чтобы совершить вызов с эти флагом, следует использовать методы `systemCall`/`systemCallWithPropagatedRevert`/`systemCallWithReturndata` библиотеки [SystemContractsCaller](https://github.com/matter-labs/v2-testnet-contracts/blob/main/l2/system-contracts/SystemContractsCaller.sol).

Использование данной библиотеки, по факту, обязательно при разработке кастомных аккаунтов, т.к. это единственный способ вызова методов (меняющих состояние сети) системного контракта `NonceHolder`. Также, вам придется использовать эту библиотеку, если вы хотите позволить пользователям самим развертывать контракты. Вы можете использовать [реализацию ЕОА-аккаунта](https://github.com/matter-labs/v2-testnet-contracts/blob/main/l2/system-contracts/DefaultAccount.sol) для справки.

### Расширенный функционал EIP4337 <a href="#extending-eip4337" id="extending-eip4337"></a>

Для обеспечения защиты оператора от DoS  оригинальный EIP4337 накладывает несколько [ограничений](https://eips.ethereum.org/EIPS/eip-4337#simulation) на этапе валидации аккаунта. Большинство из них, особенно в отношении запрещенных опкодов все еще актуальны. Однако, некоторые ограничения были сняты для лучшего пользовательского опыта.

#### Расширенный список разрешенных опкодов <a href="#extending-the-allowed-opcodes" id="extending-the-allowed-opcodes"></a>

* Разрешены методы вызова контрактов `call`/`delegateCall`/`staticcall` которые уже были развернуты. В отличие от Эфириума, у нас нет возможности отредактировать уже развернутый код или удалить контракт через selfdestruct, так что мы можем быть уверены, что код контракта во время исполнения всегда будет одним и тем же.

#### Расширенный набор слотов в хранилище, принадлежащих пользователю <a href="#extending-the-set-of-slots-that-belong-to-a-user" id="extending-the-set-of-slots-that-belong-to-a-user"></a>

В оригинальном EIP, этап `validateTransaction`  абстрагированного аккаунта позволяет аккаунту читать только слоты хранилища, принадлежащие ему самому. Однако существуют слоты, которые _семантически_ принадлежат данному пользователю, а по факту расположены  в адресах других контрактов. Яркий пример - баланс `ERC20`.

Это ограничение обеспечивает защиту от DDoS путем обеспечения уверенности в том, что слоты, используемые для валидации разными аккаунтами _не пересекаются,_ таким образом, для них нет необходимости _фактически_ принадлежать хранилищу аккаунта.

Для включения возможности чтения пользовательского баланса или разрешения на трату ERC20 на этапе валидации, следующие типы слотов будут доступны для аккаунта с адресом `A` на этапе валидации:

1. Слот, принадлежащий адресу `A`.
2. Слоты `A` на любых других адресах.
3. Слоты типа `keccak256(A || X)` на любых других адресах (для покрытия `mapping(address => value)`, которые обычно используется для баланса в токенах ERC20.
4. Слоты типа `keccak256(X || OWN)` на любых других адресах, где `OWN` - это слот предыдущего (3го) типа (для покрытия `mapping(address ⇒ mapping(address ⇒ uint256))` , которые обычно используется для `allowances` в токенах ERC20.

#### Что еще может стать доступным в будущем? <a href="#what-could-be-allowed-in-the-future" id="what-could-be-allowed-in-the-future"></a>

В будущем мы даже можем добавить транзакции с привязкой ко времени, например позволив проверять, возвращает ли `block.timestamp <= value` результат `false`, и подобные. Это потребует развертывания отдельной библиотеки таких доверенных методов, но это значительно увеличить возможности аккаунтов.

### Создание кастомных аккаунтов <a href="#building-custom-accounts" id="building-custom-accounts"></a>

Как уже было упомянуто, в каждом аккаунте должен быть реализован интерфейс [IAccount](https://v2-docs.zksync.io/dev/zksync-v2/aa.html#iaccount-interface).

Пример реализации интерфейса АА - [реализация](https://github.com/matter-labs/v2-testnet-contracts/blob/6a93ff85d33dfff0008624eb9777d5a07a26c55d/l2/system-contracts/DefaultAA.sol#L16) ЕОА аккаунта. Учтите, что этот аккаунт, прямо как стандартный ЕОА-аккаунт ан Эфириуме, успешно возвращает пустое значение всякий раз, когда его вызывает внешний адрес, в то время как это не совсем то, чего вы хотите для своего аккаунта.

#### EIP1271 <a href="#eip1271" id="eip1271"></a>

Если вы строите смарт-кошелек, мы _настоятельно рекомендуем_ вам реализовать схему валидации подписи (signature-validation) [EIP1271](https://eips.ethereum.org/EIPS/eip-1271). Это стандарт, продвигаемый командой zkSync. Он используется в библиотеке signature-validation, описанной далее в этом разделе.

#### Процесс развертывания <a href="#the-deployment-process" id="the-deployment-process"></a>

Процесс развертывания логики учетных записей очень похож на процесс развертывания смарт-контракта. Для защиты смарт-контрактов, которые не хотят быть классифицированы как аккаунт, необходимо использовать иной метод системного контракта 'deployer'. Вместо использования `create`/`create2` вам нужно использовать метод `createAccount`/`create2Account` системного контракта deployer.

Вот пример, как развернуть логику аккаунта с помощью `zksync-web3` SDK:

```typescript
import { ContractFactory } from "zksync-web3";

const contractFactory = new ContractFactory(abi, bytecode, initiator, "createAccount");
const aa = await contractFactory.deploy(...args);
await aa.deployed();
```

#### Ограничения этапа верификации <a href="#limitations-of-the-verification-step" id="limitations-of-the-verification-step"></a>

{% hint style="warning" %}
**Еще не реализовано**

Правила верификации пока не требуют полного соблюдения. Даже если ваш кастомный аккаунт сейчас работает нормально, он может перестать работать в будущем, если он не соответствует правилам ниже
{% endhint %}

Для защиты системы от угрозы DoS этап верификации должен следовать следующим ограничениям:

* Логика аккаунта может взаимодействовать только со слотами хранилища, принадлежащими данному аккаунту. Учтите, что [определение принадлежности](podderzhka-abstrakcii-akkaunta-aa.md#extending-the-set-of-slots-that-belong-to-a-user) выходит далеко за рамки слотов на адресе пользователя.
* Логика аккаунта не может использовать контекстные переменные (напр. `block.number`)
* Также необходимо, чтобы nonce аккаунта увеличивался на 1. Это ограничение нужно только для того, чтобы сохранить хэш транзакции резистентным к коллизии. В будущем это требование будет убрано для возможности реализации более общих вариантов использования (например, протоколов приватности)

Транзакции, нарушающие вышеперечисленные правила, не будут приняты API, хотя эти требования не могут быть навязаны на уровне сети/VM и неприменимы к транзакциям L1>L2.

Чтобы позволить вам как можно быстрее опробовать функцию, мы решили публично выпустить абстракцию аккаунта, прежде чем полностью реализовать проверки ограничений на этапе верификации аккаунта. В настоящее время ваши транзакции могут проходить через API, несмотря на нарушения вышеуказанных правил, но вскоре это будет изменено.

#### Контракт Nonce holder <a href="#nonce-holder-contract" id="nonce-holder-contract"></a>

В целях оптимизации, и[ nonce транзакции и nonce развертывания](https://v2-docs.zksync.io/dev/developer-guides/contracts/contracts.html#differences-in-create-behaviour) сохраняются в один слот хранилища внтури системного контракта [NonceHolder](https://v2-docs.zksync.io/dev/developer-guides/contracts/system-contracts.html#inonceholder). Для увеличения nonce вашего аккаунта крайне рекомендуется вызывать функцию [incrementNonceIfEquals](https://github.com/matter-labs/v2-testnet-contracts/blob/0e1c95969a2f92974370326e4430f03e417b25e7/l2/system-contracts/interfaces/INonceHolder.sol#L10) и передать значение nonce, предоставленное в транзакции.

Это один из разрешенных вызовов, в котором логике аккаунта позволяется вызывать внешние смарт-контракты.

#### Отправка транзакций с аккаунта <a href="#sending-transactions-from-an-account" id="sending-transactions-from-an-account"></a>

На данный момент поддерживаются только транзакции типа EIP712. Чтобы отправить транзакцию с конкретного аккаунта, вам нужно ввести в поле `from` адрес отправителя, а в поле `customSignature` (часть `customData`)- подпись для аккаунта.&#x20;

```typescript
import { utils } from "zksync-web3";

// here the `tx` is a `TransactionRequest` object from `zksync-web3` SDK.
// and the zksyncProvider is the `Provider` object from `zksync-web3` SDK connected to zkSync network.
tx.from = aaAddress;
tx.customData = {
  ...tx.customData,
  customSignature: aaSignature,
};
const serializedTx = utils.serialize({ ...tx });

const sentTx = await zksyncProvider.sendTransaction(serializedTx);
```

### Paymaster'ы <a href="#paymasters" id="paymasters"></a>

Представьте себе возможность оплачивать транзакции комиссии за пользователей вашего протокола! Paymaster - это аккаунт, который может компенсировать затраты на транзакции других аккаунтов. Представьте возможность оплачивать транзакции за пользователей вашего протокола! Другим важным вариантов использования paymaster является способствование оплате комиссий в токенах ERC20. Хоть ETH и является главным токеном zkSync, paymaster'ы могут предоставить возможность обменивать токены ERC20 на ETH "на лету".

Если пользователь захочет взаимодействовать с paymaster'ом, ему нужно предоставить ненулевой адрес `paymaster`'a в своей транзакции типа EIP712. Вводные данные для paymaster'a предоставляются в его поле `paymasterInput.`

#### Правила верификации для Paymaster <a href="#paymaster-verification-rules" id="paymaster-verification-rules"></a>

{% hint style="warning" %}
**Еще не реализовано**

Правила верификации пока не требуют полного соблюдения. Даже если ваш paymaster сейчас работает нормально, он может перестать работать в будущем, если он не будет соответствовать правилам ниже
{% endhint %}

Поскольку доступ к одному и тому же paymaster'у должен быть у многих пользователей, злоумышленники могут проводить DoS-атаку на нашу систему. Для решения этой проблемы будет использоваться система, аналогичная [системе оценки репутации EIP4337](https://eips.ethereum.org/EIPS/eip-4337#reputation-scoring-and-throttlingbanning-for-paymasters).

В отличие от оригинального EIP, paymaster'ы могут взаимодействовать с любыми слотами хранилища. Кроме того, paymaster не будет заторможен, если одно из следующих утверждений верно:

* Прошло более чем `X` минут с момента прохождения верификации на API-узлах. (Точное значение `X` будет определено в будущем).
* Порядок считываемых слотов такой же, как и при запуске API-узла и первый слот, значение которого изменилось, является одним из слотов пользователя. Это необходимо для защиты paymaster'a от вредоносных пользователей (например, пользователь мог отозвать разрешение на трату токена ERC20).

#### Встроенные порядки исполнения paymaster'a <a href="#built-in-paymaster-flows" id="built-in-paymaster-flows"></a>

В то время как некоторые paymaster'ы могут тривиально работать без какого-либо взаимодействия со стороны пользователямей (например, протокол, который всегда оплачивает комиссию за своих пользователей), другие требуют активного участия от отправителя транзакции. Примечательным примером является paymaster, который обменивает пользовательские токены ERC20 на ETH, так как он требует от пользователя установить необходимое разрешение на трату для paymaster'a.

Протокол абстракции аккаунтов сам по себе является универсальным и позволяет как аккаунтам, так и paymaster'aм реализовывать произвольные взаимодействия. Однако код обычных аккаунтов (ЕОА) является постоянным, но мы все еще хотим, чтобы они могли участвовать в экосистеме кастомных аккаунтов и paymaster'ов. Поэтому мы стандартизировали поле транзакции `paymasterInput`, чтобы охватить наиболее распространенные варианты использования функции paymaster.

Ваши аккаунты свободны в вопросе реализации поддержки этих порядков исполнения. Тем не менее, настоятельно рекомендуется сохранить интерфейс одинаковым как для ЕОА, так и для кастомных аккаунтов.

#### **Обычный порядок исполнения Paymaster**

Следует использовать, если нет нужды в предварительных действиях со стороны пользователя для работы paymaster'a.

Поле `paymasterInput` должно кодироваться как вызов функции со следующим интерфейсом:

```solidity
function general(bytes calldata data);
```

EOA-аккаунты ничего не будут делать и paymaster может интерпретировать эту `data` любым способом.

#### **Порядок исполнения paymaster, основанный на разрешении тратить токены (approval/allowance)**

Следует использовать, если от пользователя требуетя установить конкретное разрешение на трату токена для работы paymaster'a. Поле `paymasterInput` должно быть закодировано как вызов функции со следующей подписью:

```solidity
function approvalBased(
    address _token, 
    uint256 _minAllowance, 
    bytes calldata _innerInput
)
```

ЕОА убеждается, что разрешение на трату `_token`'a в пользу paymaster'a установлено как минимум на значении `_minAllowance.` Paymaster может интерпретировать `_innerInput` как ему угодно.

Если вы разрабатывается paymaster, вам _не следует_ верить __ в честное поведение __ отправителя транзакции (например, предоставлять требуемоу разрешение на трату вместе с порядком исполнения `approvalBased`)&#x20;

**Работа с порядком исполнения paymaster с использованием `zksync-web3` SDK**

`zksync-web3` SDK предоставляет [методы](https://v2-docs.zksync.io/api/js/utils.html#encoding-paymaster-params) кодировки корректно отформатированных параметров paymaster'a для все встроенных сценариев исполнения paymaster'a.

### Testnet paymaster <a href="#testnet-paymaster" id="testnet-paymaster"></a>

Чтобы позволить пользователям попрактиковаться с paymaster'ами на testnet, а также продолжить поддержку оплаты комиссий в токенах ERC20, команда Matter Labs предоставляет testnet paymaster'a, который позволяет оплачивать комиссии в ERC20-токенах по курсу 1:1 к ETH (т.е. одна единица этого окена равна 1 wei ЕТН).

Paymaster поддерживает только [approval-based](https://v2-docs.zksync.io/dev/developer-guides/aa.html#approval-based-paymaster-flow) порядок исполнения paymaster'ов и требует, чтобы параметр `token` был равен обмениваемому токену, а `minAllowance` был равен как минимум `tx.maxFeePerErg * tx.ergsLimit`.

Пример использования testnet paymaster можно увидеть в руководстве [Быстрый старт](../../rukovodstvo-razrabotchika/bystryi-start.md).

### `aa-signature-checker` <a href="#aa-signature-checker" id="aa-signature-checker"></a>

Ваш проект может начать подготовку к нативной поддержке АА. Мы настоятельно рекомендуем вам заняться этим, так как это позволит вам принять сотни тысяч пользователей (как пример, пользователи Argent, которые уже используют первую версию zkSync). Мы ожидаем, что в будущем еще больше пользователей перейдут на смарт-кошельки.

Одним из наиболее заметных различий между различными типами создаваемых аккаунтов является различные схемы подписей. Мы ожидаем, что аккаунты будут поддерживать стандарт [EIP-1271](https://eips.ethereum.org/EIPS/eip-1271). Наша команда создала библиотеку утилит для проверки подписей аккаунтов. В настоящее время она поддерживает только подписи ECDSA, но очень скоро мы добавим поддержку EIP-1271.

Библиотека `aa-signature-checker` предоставляет возможность проверки подписей для различных вариантов реализации аккаунтов. В настоящее время он поддерживает только проверку подписей ECDSA. Очень скоро мы добавим поддержку EIP-1271.

_Мы настоятельно рекомендуем Вам использовать эту библиотеку всякий раз, когда Вам необходимо проверить правильность подписи аккаунта._

#### Добавление библиотеки в ваш проект: <a href="#adding-the-library-to-your-project" id="adding-the-library-to-your-project"></a>

```
yarn add @matterlabs/signature-checker
```

#### Пример использования библиотеки

```solidity
pragma solidity ^0.8.0;

import { SignatureChecker } from "@matterlabs/signature-checker/contracts/SignatureChecker.sol";

contract TestSignatureChecker {
    using SignatureChecker for address;

    function isValidSignature(
        address _address,
        bytes32 _hash,
        bytes memory _signature
    ) public pure returns (bool) {
        return _address.checkSignature(_hash, _signature);
    }
}
```

### Верификация AA-подписей через наш SDK <a href="#verifying-aa-signatures-within-our-sdk" id="verifying-aa-signatures-within-our-sdk"></a>

**Не рекомендуется** использовать библиотеку `ethers.js` для проверки пользовательских подписей.

Наш SDK предоставляет 2 метода с его утилитами `utils` для проверки подписи аккаунта:

```javascript
export async function isMessageSignatureCorrect(address: string, message: ethers.Bytes | string, signature: SignatureLike): Promise<boolean>;

export async function isTypedDataSignatureCorrect(
  address: string,
  domain: TypedDataDomain,
  types: Record<string, Array<TypedDataField>>,
  value: Record<string, any>,
  signature: SignatureLike
): Promise<boolean>;
```

В настоящее время эти методы поддерживают только проверку подписей ECDSA, но очень скоро они также будут поддерживать и проверку подписей EIP1271.

Оба метода возвращают `true` или `false` в зависимости от правильности подписи сообщения.
