# Contract Verification

## What is contract verification?

When you deploy a smart contract on a network, you’re essentially deploying the bytecode produced by the Solidity compiler.

Verifying a contract entails determining whether the on-chain bytecode generated from the Smart Contract source code complies. If it does, we can state that we have confirmed the bytecode's source code's integrity. Hence the name – verification.


## How are smart contracts verified in zkSync?

The deployed bytecode and the Solidity source code of a smart contract are compared during the verification process using zkSync. The algorithm compiles the source code to compare the generated bytecode to the deployed one.
<br>
If the two sides match in every way, the contract is verified.

Code verification requires six arguments: 

- The compiler address
- The contract name
- The source code, including the source of all imports
- The version of the compiler used to produce the deployed bytecode
- Information about the number of compiler optimizations (if any)
- The constructor arguments
 
 If any of these pieces of information is wrong, the process of verification fails.


## Source code privacy

When your smart contract is deployed on zkSync and verified on the block explorer, users are able to check the verified source code and interact with it.



## Verifying Contracts Using the zkSync Block Explorer

You can verify your contract so that zkSync can convert it all into a format that is readable by everyone. It is beneficial if you want to make the most of our zkEVM Debugger capabilities.

To get started click the **Tools** tab in the top header, a dropdown will pop up and select **Smart Contract Verification**,  after which you will be shown the following screen:

![Smart Contract Verification page!](../../assets/images/verify-contract.png "verify contact")



### Enter contract details

To verify the contract, enter the following details;

- Contract address: The address provided must match with `0x` address supplied during contract creation.
- Contract name: The name must be identical to the name provided in the contract.
- Optimization: This checks whether or not optimization was used while compiling the contract, If you enabled optimization during compilation, check **Yes** otherwise select **No**
- Compiler version: This specifies the exact version of the compiler used to compile a smart contract. Click on the dropdown to specify the compiler version used.
  
<br>

![Compiler version!](../../assets/images/compiler-version.png "compiler version")

- Enter the Solidity Contract code: Copy the code from your editor and paste in the text area.
<br>
**Note:** You may need to flatten your Solidity code if it utilizes a library or inherits dependencies from another contract. 
<br> 
We recommend using the [truffle flattener](https://github.com/NomicFoundation/truffle-flattener) or the [POA Solidity flattener](https://github.com/poanetwork/solidity-flattener).


- Constructor arguments: If constructor arguments are required by the contract, you should add them here, but in [ABI hex encoded form](https://solidity.readthedocs.io/en/develop/abi-spec.html).
  
<br>

### How can you obtain your constructor arguments?

> **Note:** The easiest way to get the constructor argument data is to print it to the console while deploying.

For example, if using our [tutorial](./hello-world.md), you can find line:

```js
const greeterContract = await deployer.deploy(artifact, [greeting]);
```

if you add the next line as

```js
console.log(greeterContract.interface.encodeDeploy([greeting]);
```

then you will receive constructor argument data.

- Lastly, click the **Verify Smart Contract** button.
  
<br>
If all goes well, you will see a success message.

<br>

![Smart Contract Verified!](../../assets/images/contract-verified.png "Contract Verified")



